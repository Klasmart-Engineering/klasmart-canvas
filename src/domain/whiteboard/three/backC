import React from 'react';
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
import { WhiteboardContext } from '../WhiteboardContext';
import './styles.css';

type ICanvas3dProps = {
  // set3dImage: (image: string) => void;
  width: number;
  height: number;
};
type Canvas3dState = {
  // image: string;
};

class Canvas3d extends React.Component<ICanvas3dProps> {
  static contextType = WhiteboardContext;

  // mount: HTMLDivElement | null | undefined;
  scene: THREE.Scene;
  mesh: THREE.Mesh;

  constructor(props: ICanvas3dProps) {
    super(props);
    this.scene = new THREE.Scene();
    this.mesh = new THREE.Mesh();
  }

  init = () => {
    const canvas = document.querySelector('#three');
    const renderer = new THREE.WebGLRenderer({
      canvas: canvas as HTMLCanvasElement,
      alpha: true,
    });
    renderer.setClearColor(0xffffff, 0);
    renderer.setSize(this.props.width, this.props.height);

    const fov = 75;
    const aspect = 2; // the canvas default
    const near = 0.1;
    const far = 25;
    const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
    camera.position.z = 2;

    const controls = new OrbitControls(camera, canvas as HTMLElement);
    controls.target.set(0, 0, 0);
    controls.update();

    this.addLight(-1, 2, 4);
    this.addLight(1, -1, -2);

    // this.mount?.appendChild(renderer.domElement);

    const boxWidth = 1;
    const boxHeight = 1;
    const boxDepth = 1;
    const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);

    const d = 0.8;
    this.makeInstance(geometry, -d, -d, -d);

    function resizeRendererToDisplaySize(renderer: THREE.Renderer) {
      const canvas = renderer.domElement;
      const width = canvas.clientWidth;
      const height = canvas.clientHeight;
      const needResize = canvas.width !== width || canvas.height !== height;
      if (needResize) {
        renderer.setSize(width, height, false);
      }
      return needResize;
    }

    let renderRequested: boolean | undefined = false;

    const render = () => {
      renderRequested = undefined;

      if (resizeRendererToDisplaySize(renderer)) {
        const canvas = renderer.domElement;
        camera.aspect = canvas.clientWidth / canvas.clientHeight;
        camera.updateProjectionMatrix();
      }

      renderer.render(this.scene, camera);
    };
    render();

    function requestRenderIfNotRequested() {
      if (!renderRequested) {
        renderRequested = true;
        requestAnimationFrame(render);
      }
    }

    controls.addEventListener('change', requestRenderIfNotRequested);
    window.addEventListener('resize', requestRenderIfNotRequested);
  };

  hsl(h: number, s: number, l: number) {
    return new THREE.Color().setHSL(h, s, l);
  }

  makeInstance(
    geometry: any,
    x: number,
    y: number,
    z: number,
    color: string | number | undefined | THREE.Color = 0x2194ce
  ) {
    const material = new THREE.MeshPhongMaterial({
      color,
      specular: 0x003344,
      shininess: 100,
      side: THREE.FrontSide,
      opacity: 0.5,
      transparent: true,
    });

    const cube = new THREE.Mesh(geometry, material);
    this.scene.add(cube);

    cube.position.x = x;
    cube.position.set(x, y, z);

    return cube;
  }
  addLight = (x: number, y: number, z: number) => {
    const color = 0xffffff;
    const intensity = 1;
    const light = new THREE.DirectionalLight(color, intensity);
    light.position.set(x, y, z);
    this.scene.add(light);
  };

  // componentDidMount() {
  //   this.init();
  // }

  componentDidUpdate() {
    console.log(this.context.is3dActive);
    if (!this.context.is3dActive) {
      //export
    } else {
      this.init();
    }
  }

  renderScene = () => {
    return this.context.is3dActive && <canvas id="three"></canvas>;
    // this.context.is3dActive && <div id="three" ref={(ref) => (this.mount = ref)}></div>
  };

  render() {
    return this.renderScene();
  }
}
export default Canvas3d;
